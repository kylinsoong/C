= Virtual Server
:toc: manual

== Inbound Traffic Handling

[cols="2,5a"]
|===
|Name |Description

|Self IPs
|使用 external self IP 可以访问管理界面（需要配置 Port Lockdown，允许 443 端口）。

[source, text]
.*查看外部 vlan Self IP*
----
# list net self 10.1.10.240 
net self 10.1.10.240 {
    address 10.1.10.240/24
    allow-service {
        tcp:ssh
        tcp:https
    }
    traffic-group traffic-group-local-only
    vlan external
}
----

*访问管理界面*

https://10.1.10.240

NOTE: 不建议使用业务流量接入的 external vlan 访问系统，推荐使用管理在安装初始化时创建的管理接口访问管理界面

[source, bash]
.*访问 ssh*
----
ssh root@10.1.10.240
----

|NAT
|将内网的地址直接映射到外网，处于监听模式，接收所有发往NAT地址的连接

[source, bash]
----
// create nat
create ltm nat custom_nat originating-address 10.1.20.13 translation-address 10.1.10.100

// make request
curl http://10.1.10.100/hello

// check the connections
# tcpdump -ni external host 10.1.10.100
00:11:43.652881 IP 10.1.10.1.60139 > 10.1.10.100.http: Flags [SEW], ...
# tcpdump -ni internal host 10.1.20.13
00:13:05.685271 IP 10.1.10.1.60216 > 10.1.20.13.http ...

// clean up
delete ltm nat custom_nat
----

|SNATs
|是将某一个 VLAN 上的请求转发到一个地址

[source, bash]
----
// vs is running
create ltm pool http_pool members add { 10.1.20.11:8081 { address 10.1.20.11 } 10.1.20.12:8081 { address 10.1.20.12 } }
create ltm virtual http_vs destination 10.1.10.20:80 ip-protocol tcp pool http_pool

// move 10.1.10.0 to 10.1.20.201
create ltm snat custom_snat origins add { 10.1.10.0/24 } translation 10.1.20.201

// make request
curl http://10.1.10.20/hello

// check the connections
# tcpdump -ni external host 10.1.10.20
00:01:30.871791 IP 10.1.10.1.59532 > 10.1.10.20.http: Flags [SEW], ...
# tcpdump -ni internal host 10.1.20.201
00:02:59.684393 IP 10.1.20.201.35520 > 10.1.20.11.tproxy ...

// clean up
delete ltm virtual http_vs
delete ltm pool http_pool
delete ltm snat custom_snat
----

|Virtual Servers
|
[source, bash]
----
// create VS
create ltm pool http_pool members add { 10.1.20.11:8081 { address 10.1.20.11 } 10.1.20.12:8081 { address 10.1.20.12 } }
create ltm virtual http_vs destination 10.1.10.20:80 ip-protocol tcp pool http_pool

// make request
curl http://10.1.10.20/hello

// check connections
# tcpdump -ni external host 10.1.10.20
00:19:27.352896 IP 10.1.10.1.60544 > 10.1.10.20.http: ...
# tcpdump -ni internal host 10.1.20.11 or 10.1.20.12
00:21:17.840726 IP 10.1.10.1.35715 > 10.1.20.11.tproxy: ...

// Clean up
delete ltm virtual http_vs 
delete ltm pool http_pool
----
|===

== VS Type

本部分说明不同 VS 类型的使用场景及注意事项。本部分的内容（包括图片）参照 https://support.f5.com/csp/article/K8082（该文章可以从互联网上找到）。

=== Standard

* Standard 下客户端连接和服务器端连接是 1:1 的关系，基于全代理模式，客户端和服务器端的TCP连接完全独立
* 客户端和服务器端的 TCP 参数都是由 TMM 和双方分别协商
* 默认情况下以客户端源 IP 和后台建立连接，在打开 SNAT 的情况下用 SNAT 地址和后台建立连接
* Standard VS 的端口永远对外开放，无论后台是否有服务器在工作

Standard 模式下根据 VS 是否关联 L7 层协议，连接建立和数据流程稍有不同，详细如下：

==== Standard VS 数据流程（仅TCP profile）

image:img/vs-type-standard-tcp.jpeg[]

1. Client 和 LTM 三次握手建立 TCP 连接
2. LTM 选择一个 Pool Member
3. LTM 和 Pool Member 三次握手建立 TCP 连接
4. Client 开始发送数据

[source, bash]
.*示例*
----
// 1. create VS
create ltm pool echo_pool members add { 10.1.20.11:8877 { address 10.1.20.11 } 10.1.20.12:8877 { address 10.1.20.12 } } 
create ltm virtual echo_vs destination 10.1.10.27:8877 ip-protocol tcp pool echo_pool 

// 2. start the echo client, this will establish the tcp connection without send any data
./echoclient 10.1.10.27


// 3. check the connection tables
# show sys connection cs-server-addr 10.1.10.27
Sys::Connections
10.1.10.128:46262  10.1.10.27:8877  10.1.10.128:16587  10.1.20.11:8877  tcp  7  (tmm: 0)  none  none

// 4. check from the established connection from server(no data send)
# netstat -antulop | grep 8877 | grep ESTABLISHED
tcp        0      0 10.1.20.11:8877         10.1.10.128:16587       ESTABLISHED 4322/echoserver  off (0.00/0/0)

// 5. send data 
$ ./echoclient 10.1.10.27
time
1581765040
daytime
Sat Feb 15 03:13:32 2020
chargen
u$a71i0Rkk*1LkQ46d2Dqtau4Pn1cU;tZ8G'#Xsn_};-&)\<

// 6. exit the echo client, wait some time and check connection table 
# show sys connection cs-server-addr 10.1.10.27
Sys::Connections
Total records returned: 0

// 7. Clean up
delete ltm virtual echo_vs
delete ltm pool echo_pool 
----

==== Standard VS 数据流程（L7 profile）

image:img/vs-type-standard-http.jpeg[]

1. Client 和 LTM 三次握手建立 TCP 连接
2. LTM 等待 Client 端发送 7 层请求
3. Client 发送 HTTP GET 
4. LTM 选择一个 Pool Member
5. LTM 和 Pool Member 三次握手建立 TCP 连接
6. LTM 将 HTTP 请求转发给

NOTE: 和单纯的 TCP profile 关联的最大不同在于TMM必须等待到第一个客户端有效数据包之后才和后台服务器建立连接

[source, bash]
.*示例*
----
// 1. create vs
create ltm pool http_pool members add { 10.1.20.11:8081 { address 10.1.20.11 } 10.1.20.12:8081 { address 10.1.20.12 } }
create ltm virtual http_vs destination 10.1.10.20:80 ip-protocol tcp profiles add { http { } } pool http_pool 

// 2. send 3 http request without send do GET method
java -jar target/http-client-0.0.1-SNAPSHOT.jar 10.1.10.20 80

// 3. check the connection table
# show sys connection cs-server-addr 10.1.10.20
Sys::Connections
10.1.10.1:60077  10.1.10.20:80  any6.any  any6.any  tcp  48  (tmm: 1)  none  none
10.1.10.1:60076  10.1.10.20:80  any6.any  any6.any  tcp  48  (tmm: 0)  none  none
10.1.10.1:60075  10.1.10.20:80  any6.any  any6.any  tcp  48  (tmm: 0)  none  none
Total records returned: 3

// 4. check the established connection from backend server(there should be none) 
# netstat -antulop | grep 8081
tcp6       0      0 :::8081                 :::*                    LISTEN      2827/apache2     off (0.00/0/0)

// 5. Clean up
delete ltm virtual http_vs
delete ltm pool http_pool
----

=== Performance (Layer 4)



=== Performance (HTTP)


=== Forwarding (Layer 2)


=== Forwarding (IP)


=== Reject




[cols="2,5a"]
|===
|Name |Description

|Standard
|

|Forwarding(IP)
|
[source, bash]
----
create ltm virtual forwarding_virtual destination 10.1.20.0:0 mask 255.255.255.0 ip-forward ip-protocol any
----

|Reject
|
[source, bash]
----
create ltm virtual reject_ssh_virtual destination 10.1.20.0:22 mask 255.255.255.0 reject ip-protocol tcp
----

|===
